/*
 * BOJ 15246 (not full code)
 * https://www.acmicpc.net/problem/15246 
 */

#include <bits/stdc++.h>
#define fastio cin.tie(0)->sync_with_stdio(0)
using namespace std;

struct BCC { // edge-disjoint BCC
	int n, dfs_cnt, color_cnt;
	vector<int> dfs_order, low, v;
	vector<vector<int>> color;
	vector<pair<int, int>> bridge;
	vector<vector<pair<int, int>>> adj;

	BCC(int n) :
		n(n), adj(n + 1), v(n + 1),
		dfs_order(n + 1), low(n + 1),
		color(n + 1), dfs_cnt(0), color_cnt(0) {}

	void AddEdge(int a, int b, int idx) {
		adj[a].push_back({ b, idx });
		adj[b].push_back({ a, idx });
	}

	void InitDummy() {
		vector<int> visited(n + 1);
		for (int i = 1; i <= n; i++) {
			if (visited[i]) continue;
			queue<int> Q; AddEdge(i, 0, 1e9);
			visited[i] = 1, Q.push(i);
			while (Q.size()) {
				auto cur = Q.front(); Q.pop();
				for (const auto& [nxt, idx] : adj[cur])
					if (!visited[nxt]) visited[nxt] = 1, Q.push(nxt);
			}
		}
	}

	int DFS(int cur, int prv_idx = -1) {
		int& ret = low[cur] = dfs_order[cur] = ++dfs_cnt;
		for (const auto& [nxt, idx] : adj[cur]) {
			if (idx == prv_idx) continue;
			if (!dfs_order[nxt]) {
				const int t = DFS(nxt, idx);
				if (t > dfs_order[cur] && cur && nxt) bridge.push_back({ cur, nxt });
				ret = min(ret, t);
			}
			else ret = min(ret, dfs_order[nxt]);
		}
		return ret;
	}

	void Color(int cur, int p) {
		if (p) {
			color[p].push_back(cur);
			v[cur] = p;
		}
		for (const auto& [nxt, idx] : adj[cur]) {
			if (v[nxt] || !nxt) continue;
			if (low[nxt] > dfs_order[cur]) Color(nxt, ++color_cnt);
			else Color(nxt, p);
		}
	}

	void GetBridge(bool flag = 0) {
		InitDummy(); DFS(0); Color(0, 0);
		for (auto& [a, b] : bridge) if (a > b) swap(a, b);
		sort(bridge.begin(), bridge.end());

		if (flag) {
			cout << '\n' << "bridge :" << '\n';
			cout << bridge.size() << '\n';
			for (auto& [a, b] : bridge) cout << a << ' ' << b << '\n';
			cout << '\n';

			cout << "color :" << '\n';
			for (int i = 1; i <= color_cnt; i++) {
				for (const auto& j : color[i]) cout << j << ' ';
				cout << '\n';
			}
			cout << '\n';
		}
	}
};

int main() {
	fastio;
	int n, m; cin >> n >> m;
	vector<pair<int, int>> edge(m); BCC B(n);
	for (int i = 0; i < m; i++) {
		int a, b; cin >> a >> b;
		edge[i] = { a, b };
		B.AddEdge(a, b, i);
	}
	B.GetBridge(1);
}

/*
# in_1
9 10
1 2
2 3
2 3
3 4
4 5
4 6
3 6
6 7
6 8
8 9

# in_2
5 6
1 2
1 2
4 3
2 3
1 3
5 1
*/